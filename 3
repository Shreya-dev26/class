//bcd to hex

section .bss
num resb 6
section .data
digit db 0 ;single digit store before display
temp dw 0 ;after rotating
mult dw oAh
product dw 0
msg1 db "Enter 5 digit BCD number:",10
msg1len equ $-msg1
msg2 db "Hex Equivalent number:",10
msg2len equ $-msg2
%macro operat 4
mov rax,%1
mov rdi,%2
mov rsi,%3
mov rdx,%4 syscall
%endmacro
section .text
global _start
_start:
operat 1,1, msg1,msg1len
operat 0,0, num,6 ;BCD no e.g.123
mov rsi,num
mov cx,0ah
mov ax,0
mov bx,0
up: mov bl, [rsi]
cmp bl,0ah
je skip
sub bl,30h ;extract the digit
mul cx ;multiply by 0ah
add ax,bx ;add the digit to product
inc rsi
jmp up

skip:

call disp
operat 60,0, 0,0

disp:

mov [temp],ax
operat 1,1, msg2,msg2len
mov ax, [temp]
nextdigit: rol ax,4
mov [temp],ax
and ax,0Fh
cmp al,09h
jbe down
add al,07h
down: add al, 30h
mov [digit],al
operat 1,1,digit,1
mov ax, [temp]
dec byte[count]
jnz nextdigit
ret


//convert decimal 9999D = 270FH

mov ax,word[Number]
mov bx,10H
mov rdi,num+4

loop3:

mov dx,0
div bx
cmp dl,09h
jbe down1
add dl,07h
down1: add dl,30h
mov [rdi],dl
dec rdi
cmp ax,0
jne loop3

scall 1,1,msg,msglen
scall 1,1,num,5
;BCD to HEX conversion (Can convert maximum 4
digit BCD number to Hexadecimal)

%macro scall 4
mov rax,%1
mov rdi,%2
mov rsi,%3
mov rdx,%4
syscall
%endmacro
section .data
Number dw 9999d
msg db 10d,13d,"Equivalent HEX Number is: "
msglen equ $-msg
section .bss
num resb 5
section .code
global _start
_start:
mov ax,word[Number]
mov bx,10H
mov rdi,num+4

loop3:

mov dx,0
div bx
cmp dl,09h
jbe down1
add dl,07h
down1: add dl,30h
mov [rdi],dl
dec rdi
cmp ax,0
jne loop3
scall 1,1,msg,msglen
scall 1,1,num,5

exit:
mov rax,60
mov rdx,0
syscall
